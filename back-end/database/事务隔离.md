## 数据库同步
最近工作中有一个数据同步的要求：
客户原本有一个管理系统，目前开发新项目的过程中，要把新产生的数据同步到SQLServer上，同时SQLServer上的数据也要定时同步到Postgres上面
客户的要求分三种情况：
* 每十分钟定时启动后台方法，把SqlServer侧的指定表数据同步到Postgres
* 数据删除（因为特殊原因，不存在逻辑删除flg，是物理删除）
* 每十分钟定时启动后台方法，把Postgres侧的指定表数据同步到SqlServer，同步成功后，把Postgres侧的某个状态字段修改为已完成
* 某个表涉及到双向同步，每十分钟此表数据从SqlServer侧同步到Postgres,每五分钟Postgres数据同步到SqlServer,其中某些字段的值以Postgres侧为准，某些字段值以SqlServer侧为准，某些值如备注根据特定规则进行整合。
## 思路
* 配置多数据源
  根据使用的ORM框架使用不同的方式配置双数据源，如mybatis，Hibernate等。使应用同时连接Posters和SqlServer数据库，并做测试。
* 数据同步
  **情况一**
  第一种情况是最简单的一种，需要做的仅是从数据从SqlServer取出，添加进Postgres
  * 在Postgres侧新建一个同步历史表，如`syncTimeTable`，字段名为需要同步的表名和最后同步时间
  * 程序运行前从`syncTimeTable`中拿到上次同步到的时间戳。
  * SqlServer侧根据拿到的时间戳在数据中做检索，得到所有需要同步的数据
  * 拿到需要同步的数据中，有一部分是Postgres中已经存在的，有一些是不存在的。所以数据不能直接更新或插入进Postgres中

* 数据同步
* 事务隔离的四种级别
  * read uncommitted
    * 脏读
  * read committed
    * 不会造成脏读，但是会有不可重复读的可能
  * repeatable read
    * 不能读取事务正在处理的数据，也不能修改事务处理数据前的数据
  * serializabl
  * snapshot
    * 指定事务在开始的时候，就获得了已经提交数据的快照，因此当前事务只能看到事务开始之前对数据所做的修改。

  如果对数据安全，数据库完整性和一致性又特殊要求的用户，就可以自己显视地使用数据库的锁机制。PostgreSQL提供了多种锁模式用于控制对表中数据的并发访问

* 锁
 * 锁类型： 
   * 行级锁
    * FOR UPDATE
      导致由SELECT语句检索到的行被锁定，就好像它们要被更新。这可以阻止它们被其他事务锁定、修改或者删除，一直到当前事务结束
    * FOR SHARE
    * for ...
   * 表级锁
    * 表级锁模式
      * ACCESS SHARE
      * ACCESS EXCLUSIVE
   * 页锁


* 更新排他：
  乐观锁，一个与业务逻辑无关的字段，比如更新回数等


没有想到的一些东西，比如触发器的使用，等等
stream API

？关于隔离级别哪里要怎么往下顺？？
表现的行为不太一样，sqlserver上对数据进行操作，再对相关数据进行查询就会造成堵塞，postgres上没有这种情况。
当启用了行版本控制的隔离级别后，数据库引擎讲维护每一行的版本，使用行版本查看事务或者查询开始存在的数据，而不是使用锁保护所有读取。